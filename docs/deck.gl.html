<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>kamzek-weather</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/5.16.0/d3.min.js"></script>
    <script src="https://unpkg.com/deck.gl@8.5.0-alpha.5/dist.min.js"></script>
    <!--
    <script src="https://unpkg.com/@deck.gl/core@8.5.0-alpha.5/debug.min.js"></script>
    <script>
        deck.log.enable()
        deck.log.level = 2
        luma.log.enable()
        luma.log.level = 2
    </script>
    -->
    <script src="https://unpkg.com/@luma.gl/constants@8.4.5/dist/dist.min.js"></script>
    <script src="./deck.gl-raster.min.js"></script>
    <link href="./style.css" rel="stylesheet">
</head>
<body>
    <div id="container">
        <div id="deck"></div>
    </div>
    <div id="info">
        <div id="info1"></div>
        <div id="info2"></div>
    </div>

<script type="module">
import { getUrl, getColormapUrl, loadConfig, initGui } from './config.js';
import { LegendControl } from './legend-control.js';

function formatNumber(value, decimals = 6) {
    return Math.floor(value * 10 ** decimals) / 10 ** decimals;
}

window.addEventListener('DOMContentLoaded', async () => {
    const config = await loadConfig();

    const deckgl = new deck.Deck({
        parent: document.getElementById('deck'),
        initialViewState: {
            longitude: 30,
            latitude: 0,
            zoom: 0,
        },
        controller: {
            normalize: false,
        },
        views: [
            new deck.MapView({
                repeat: true,
            }),
        ],
        layers: [
            new deck.SolidPolygonLayer({
                id: 'background',
                data: [[[-180, 85.051129], [0, 85.051129], [180, 85.051129], [180, -85.051129], [0, -85.051129], [-180, -85.051129]]],
                getPolygon: d => d,
                stroked: false,
                filled: true,
                getFillColor: [26, 26, 26],
            }),
            new deck.GeoJsonLayer({
                id: 'countries',
                data: 'https://d2ad6b4ur7yvpq.cloudfront.net/naturalearth-3.3.0/ne_50m_admin_0_countries.geojson',
                stroked: true,
                filled: true,
                lineWidthMinPixels: 2,
                getLineColor: [61, 61, 61],
                getFillColor: [51, 51, 51],
                extensions: [new deck.ClipExtension()],
                clipBounds: [-180, -85.051129, 180, 85.051129],
            }),
        ],
    });

    let legendControl;

    function updateInfo(viewState) {
        const viewport = new deck.WebMercatorViewport(viewState);
        const bounds = viewport.getBounds();

        document.getElementById('info1').innerHTML = `
            Center: ${formatNumber(viewport.longitude)}, ${formatNumber(viewport.latitude)}<br>
            Zoom: ${formatNumber(viewport.zoom)}<br>
            Pitch: ${formatNumber(viewport.pitch)}<br>
            Bearing: ${formatNumber(viewport.bearing)}<br>
            <br>
            Bounds:<br>
            <div class="grid-2">
                ${bounds.slice(0, 2).map((x, i, array) => `<span>${formatNumber(x)}${i < array.length - 1 ? ',' : ''}</span>`).join('')}
                ${bounds.slice(2, 4).map((x, i, array) => `<span>${formatNumber(x)}${i < array.length - 1 ? ',' : ''}</span>`).join('')}
            </div><br>
        `;
    }
    function updateMouseInfo(event) {
        if (!event.coordinate) {
            return;
        }

        // TODO: RasterLayer picking, see https://github.com/kylebarron/deck.gl-raster/issues/32
        const overlayValue = undefined; // overlayLayer ? overlayLayer.getPositionValue(event.coordinate) : undefined;
        const particlesVector = undefined; // particlesLayer ? particlesLayer.getPositionVector(event.coordinate) : undefined;
        const particlesBearing = undefined; // particlesLayer ? particlesLayer.getPositionBearing(event.coordinate) : undefined;

        document.getElementById('info2').innerHTML = `
            Mouse:<br>
            Position: ${event.coordinate.map(x => formatNumber(x)).join(', ')}<br>
            Overlay Value: ${typeof overlayValue !== 'undefined' ? formatNumber(overlayValue) : 'n/a'}<br>
            Particles Vector: ${typeof particlesVector !== 'undefined' ? `${formatNumber(particlesVector[0])}, ${formatNumber(particlesVector[1])}` : 'n/a'}<br>
            Particles Bearing: ${typeof particlesBearing !== 'undefined' ? Math.round(particlesBearing) : 'n/a'}
        `;
    }
    deckgl.setProps({
        onViewStateChange: ({ viewState }) => updateInfo(viewState),
        onHover: (event) => updateMouseInfo(event),
    });

    // weather layers
    async function update() {
        const overlayUrl = getUrl(config.datasets, config.meta.dataset, config.meta.datetime);
        const overlay = await loaders.load(overlayUrl, loaders.ImageLoader);
        const colormapUrl = getColormapUrl(config.meta.dataset);
        config.overlay.colormapUrl = colormapUrl;
        const colormap = await loaders.load(colormapUrl, loaders.ImageLoader);
        const particlesUrl = getUrl(config.datasets, config.meta.particles.dataset, config.meta.particles.datetime);

        if (!legendControl) {
            legendControl = new LegendControl(config.overlay);
            const container = legendControl.onAdd();
            container.style.position = 'absolute';
            container.style.bottom = '10px';
            container.style.left = '10px';
            document.body.appendChild(container);
        } else {
            legendControl.update();
        }

        deckgl.setProps({
            layers: [
                deckgl.props.layers[0],
                deckgl.props.layers[1],
                new deck['gl-raster'].RasterLayer({
                    id: 'raster',
                    images: {
                        imageRgba: {
                            data: overlay,
                            format: luma.GL.RGB,
                            parameters: {
                                [luma.GL.TEXTURE_MIN_FILTER]: luma.GL.LINEAR,
                                [luma.GL.TEXTURE_MAG_FILTER]: luma.GL.LINEAR,
                            },
                        },
                        imageColormap: {
                            data: colormap,
                            format: luma.GL.RGB,
                            parameters: {
                                [luma.GL.TEXTURE_MIN_FILTER]: luma.GL.LINEAR,
                                [luma.GL.TEXTURE_MAG_FILTER]: luma.GL.LINEAR,
                            },
                        },
                        imageMask: {
                            data: overlay,
                            format: luma.GL.ALPHA,
                            parameters: {
                                [luma.GL.TEXTURE_MIN_FILTER]: luma.GL.LINEAR,
                                [luma.GL.TEXTURE_MAG_FILTER]: luma.GL.LINEAR,
                            },
                        },
                    },
                    modules: [
                        deck['gl-raster'].rgbaImage,
                        ...(config.overlay.vector ? [
                            deck['gl-raster'].linearRescale,
                            deck['gl-raster'].vectorLength,
                        ] : []),
                        deck['gl-raster'].colormap,
                        deck['gl-raster'].maskImage,
                    ],
                    moduleProps: {
                        linearRescaleScaler: 2,
                        linearRescaleOffset: -1,
                        colormapScaler: 1,
                        colormapOffset: 0,
                    },
                    opacity: config.overlay.opacity,
                    bounds: [-180, -90, 180, 90],
                    _imageCoordinateSystem: deck.COORDINATE_SYSTEM.LNGLAT,
                    extensions: [new deck.ClipExtension()],
                    clipBounds: [-180, -85.051129, 180, 85.051129],
                }),
            ],
        });
    }
    update();

    // GUI
    // const meta = {
    //     running: true,
    //     step: () => particlesLayer.step(),
    // };
    const gui = initGui(config, update);
    // const debug = gui.addFolder('debug');
    // debug.add(meta, 'running').onChange(() => {
    //     if (meta.running) {
    //         particlesLayer.start();
    //     } else {
    //         particlesLayer.stop();
    //     }
    // });
    // debug.add(meta, 'step');
});
</script>
</body>
</html>