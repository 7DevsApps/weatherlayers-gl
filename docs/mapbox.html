<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>maritrace-mapbox-weather</title>
    <script src="https://api.mapbox.com/mapbox-gl-js/v1.9.1/mapbox-gl.js"></script>
    <link href="https://api.mapbox.com/mapbox-gl-js/v1.9.1/mapbox-gl.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/5.16.0/d3.min.js"></script>
    <script src="../dist/maritrace-mapbox-weather.umd.js"></script>
    <style>
        body {
            margin: 0;
            font-family: 'Lucida Grande', sans-serif;
            font-size: 12px;
        }
        #map {
            width: 100vw;
            height: 100vh;
        }
        #info {
            position: absolute;
            top: 0;
            left: 15px;
        }
        #info1, #info2 {
            padding: 4px 8px;
            background: rgba(0, 0, 0, 0.5);
            color: #eee;
            backdrop-filter: blur(1px);
        }
        #info1:empty, #info2:empty {
            display: none;
        }
        #info2 {
            margin-top: 4px;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <div id="info">
        <div id="info1"></div>
        <div id="info2"></div>
    </div>

<script type="module">
import { config, initGui } from './config.js';

function round(value) {
    return Math.floor(value * 10 ** 6) / 10 ** 6;
}

window.addEventListener('DOMContentLoaded', async () => {
    config.overlay.image = await MaritraceMapboxWeather.loadImage(config.overlay.imagePath);
    config.particles.image = await MaritraceMapboxWeather.loadImage(config.particles.imagePath);

    const map = new mapboxgl.Map({
        container: 'map',
        accessToken: 'pk.eyJ1IjoiemFramFuIiwiYSI6IlB6c09JTjQifQ.pGUFp8k7f-W9IAkCrM_PYQ',
        style: 'mapbox://styles/mapbox/dark-v10',
        center: [30, 0],
        zoom: 0,
        // FIXME: overzoomed particles don't move
        // center: [6.696399, 55.020684],
        // zoom: 15.5,
        antialias: true,
    });

    const overlayLayer = new MaritraceMapboxWeather.OverlayLayer(config.overlay);
    const particlesLayer = new MaritraceMapboxWeather.ParticlesLayer(config.particles);
    const legendControl = new MaritraceMapboxWeather.LegendControl(config.overlay);
    let initialized = false;

    function step() {
        if (!particlesLayer.running) {
            particlesLayer.running = true;
            particlesLayer.running = false;
        }
    }
    const meta = {
        step: step,
    };
    async function update() {
        config.overlay.image = await MaritraceMapboxWeather.loadImage(config.overlay.imagePath);
        config.particles.image = await MaritraceMapboxWeather.loadImage(config.particles.imagePath);

        overlayLayer.update();
        particlesLayer.update();
        legendControl.update();
        map.triggerRepaint();
    }
    function addGui() {
        if (!initialized) {
            setTimeout(addGui, 500);
            return;
        }
        const gui = initGui(config, update);
        gui.add(particlesLayer, 'running');
        gui.add(meta, 'step');
    }
    addGui();

    const info1 = document.getElementById('info1');
    const info2 = document.getElementById('info2');
    const updateInfo = () => {
        const center = map.getCenter();
        const geographicCenter = MaritraceMapboxWeather.getGeographicPosition(center);
        const matrix = map.transform.customLayerMatrix();
        const worldBounds = [map.getBounds().getNorthWest(), map.getBounds().getSouthEast()]
        /** @type [[number, number], [number, number]] */
        const geographicWorldBounds = [MaritraceMapboxWeather.getGeographicPosition(worldBounds[0]), MaritraceMapboxWeather.getGeographicPosition(worldBounds[1])];

        info1.innerHTML = `
            Center: ${round(center.lng)}, ${round(center.lat)}<br>
            Center (geographic): ${round(geographicCenter[0])}, ${round(geographicCenter[1])}<br>
            Zoom: ${round(map.getZoom())}<br>
            Pitch: ${round(map.getPitch())}<br>
            Bearing: ${round(map.getBearing())}<br>
            <br>
            Matrix: <div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; grid-column-gap: 8px">${matrix.map((x, i) => `<span>${Math.round(x)}${i < matrix.length - 1 ? ',' : ''}</span>`).join('')}</div>
            <br>
            World Bounds Min: ${round(worldBounds[0].lng)}, ${round(worldBounds[0].lat)}<br>
            World Bounds Max: ${round(worldBounds[1].lng)}, ${round(worldBounds[1].lat)}<br>
            World Bounds Min (geographic): ${round(geographicWorldBounds[0][0])}, ${round(geographicWorldBounds[0][1])}<br>
            World Bounds Max (geographic): ${round(geographicWorldBounds[1][0])}, ${round(geographicWorldBounds[1][1])}
        `;
    };
    map.on('move', updateInfo);
    map.on('zoom', updateInfo);
    map.on('resize', updateInfo);
    updateInfo();

    map.on('style.load', () => {
        map.addLayer(overlayLayer, 'waterway-label');
        map.addLayer(particlesLayer, 'waterway-label');
        map.addControl(legendControl, 'bottom-left');
        updateInfo();
        initialized = true;

        map.on('mousemove', e => {
            const position = e.lngLat;
            const geographicPosition = MaritraceMapboxWeather.getGeographicPosition(position);
            const overlayValue = overlayLayer.getPositionValue(position);
            const particlesVector = particlesLayer.getPositionVector(position);
            const particlesBearing = particlesLayer.getPositionBearing(position);

            info2.innerHTML = `
                Mouse:<br>
                Position: ${round(position.lng)}, ${round(position.lat)}<br>
                Position (geographic): ${round(geographicPosition[0])}, ${round(geographicPosition[1])}<br>
                Overlay Value: ${typeof overlayValue !== 'undefined' ? round(overlayValue) : 'n/a'}<br>
                Particles Vector: ${typeof particlesVector !== 'undefined' ? `${round(particlesVector[0])}, ${round(particlesVector[1])}` : 'n/a'}<br>
                Particles Bearing: ${typeof particlesBearing !== 'undefined' ? Math.round(particlesBearing) : 'n/a'}
            `;
        });
    });
});
</script>
</body>
</html>